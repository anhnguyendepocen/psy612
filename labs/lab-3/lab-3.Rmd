---
title: "Lab 3: Univariate Regression (II) & GLM"
output: 
  html_document: 
    fig_caption: yes
    theme: cosmo
    toc: yes
    toc_depth: 3
    toc_float: TRUE
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, rows.print = 10)

# suppress scientific notation
options(scipen = 999)
```


# Purpose

Today we will briefly review of univariate regression and then will discuss how to summarize and visualize uncertainty about regression models using a variety of plotting methods. We will then touch on how to estimate regression coefficients using matrix algebra. Lastly, we will introduce the topic of the General Linear Model and demonstrate how GLM can be used to understand all of the statistical tests we have learned so far (*t*-tests, ANOVA, correlations, regressions) within one unifying framework. 

To quickly navigate to the desired section, click one of the following links:

1. [Visualizing uncertainty](#uncertainty)
1. [Regression with matrix algebra](#matrix)
1. [The General Linear Model](#glm)

You will need to load the following libraries to follow along with today's lab. If you don't have any of these packages installed, please do so now. 

```{r message=FALSE}
library(tidyverse) # for plotting and data wrangling
library(rio) # for importing data
library(psych) # for stats functions
library(broom) # for cleaning up output
library(sjPlot) # for plotting
library(ggpubr) # for plotting
library(carData) # for Guyer dataset
```

***

# Visualizing uncertainty{#uncertainty}

* We're going to use the same dataset from previous labs about the relationship between conscientiousness and self-rated health. 

## Data and review

* Load in the data

```{r}
health <- import("https://raw.githubusercontent.com/uopsych/psy612/master/labs/lab-3/data/consc_health.csv")
```
<br>

* Recall how we wrote out our model

$$Y_i = b_0 + b_1X_i + e_i$$

$$health_i = b_0 + b_1consc_i + e_i$$
<br>

* Here's how we specified the model in R

```{r}
model <- lm(sr_health ~ consc, data = health)
```
<br>

* Here are our cofficients...

```{r echo=FALSE}
tidy(model) %>% #
  rename(coefficient = term,
        b = estimate,
        SE = std.error,
        t = statistic,
        p = p.value) %>%
  mutate(p = ifelse(p > .001, round(p, 3), "< .001")) %>% 
  knitr::kable(digits = c(NA, 2, 2, 2, 3), 
               caption = "Results of Regressing Self-Reported Health on Conscientiousness") 
```
<br>

> **Question:** What do the intercept and slope mean? What do the *t*-values tell us? 

> **Answer:** Intercept = the expected value for self-rated health when conscientiousness is 0. Slope = the magnitude of the relationship between conscientiousness and self-rated health: for every 1-unit increase in conscientiousness, we expect a 0.49-unit increase in self-rated health. *t*-values are from a one-sample t-test assessing whether the slope and intercept are significantly different from 0; the *t* values represent the ratio of signal to noise (i.e. each b divided by its standard error).

## Confidence intervals

* Our `b's` (intercept and slope) are *estimates* from our sample of true population parameters ($\beta$'s). Remember that whenever we calculate an estimate of something, we should also determine how precise our estimate is. This is where standard errors and confidence intervals come in. 

* Recall the formula for calculating confidence intervals:

$$CI_b = b \pm CV(SE_b)$$

* In [Minihack 1](#minihack1) you will get some practice using this formula to calculate confidence intervals around regression coefficients. For now, we will use a much easier method: `stats::confint()`. This function takes in a fitted model object as the first argument. By default it will give you 95% CI's. 

```{r }
confint(model)
```

>**Question:** What does these 95% CI for the slope of conscientiousness mean in plain English? 

>**Answer:** If we were to repeat this experiment over and over again, sampling from the same population, 95% of the time the slope we calculate would be between 0.25 and 0.73 (i.e. in 19 out of every 20 experiments we'd get a slope in this interval). MORE GENERALLY it means that if we carried out random sampling from the population a large number of times, and calculated the 95% CI each time around our coefficients (intercept and slope), then 95% of those intervals can be expected to contain the population parameters. In other words, we have good reason to believe the true population parameters ($\beta_0$ and $\beta_1$) fall in this interval because 95% of the time such intervals contain the true population parameters.

## Confidence bands

* In addition to estimating precision around the our coefficients, we can also estimate our precision around each predicted value, $\hat{Y_i}$. These standard errors are generated by `broom::augment()` (and are labeled `.se.fit`).

```{r}
model %>% # start with our model object
  augment() %>% # from broom package; gives us fitted values, residuals, etc.
  select(sr_health, .fitted, .se.fit) # select relevant variables
```
<br>

* If we were to string all of this information together, it would generate a confidence **band** around our regression line. As we've seen already with previous examples, it's really easy to get this confidence band when creating a scatter plot by adding `geom_smooth(method = "lm")`. 

```{r}
health %>%
  ggplot(aes(x = consc, y = sr_health)) + 
  geom_point(alpha = 0.3) + 
  geom_smooth(method = "lm") + # adds a layer that includes the regression line & 95% confidence band
  labs(x = "Conscientiousness", y = "Self-rated health") +
  theme_minimal()
```

* The animation below is an example of a ["Hypothetical Outcomes Plot"](https://github.com/wilkelab/ungeviz){target="_blank"} (HOP) that visually demonstrates what this 95% CI band represents. In essence, this plot shows what the regression line could look like if we were to repeat our experiment over and over (sampling from the same population each time). 

```{r echo=FALSE}
library(ungeviz)
library(gganimate)
library(transformr)
library(gifski)

set.seed(012220)

boots <- bootstrapper(100)

p <- health %>%
  ggplot(aes(x = consc, y = sr_health)) +
  geom_smooth(method = "lm", color = NA) +
  geom_point(alpha = 0.3) +
  geom_smooth(data = boots, method = "lm", fullrange = TRUE, se = FALSE) +
  theme_minimal() +
  labs(x = "Conscientiousness", y = "Self-rated health") +
  transition_states(.draw, 1, 1) +
  enter_fade() +
  exit_fade() +
  ease_aes()

animate(p, fps = 3)

```
<br>

## Prediction

* A regression line, by definition, corresponds to the line that gives the *mean* value of `Y` corresponding to each possible value of `X`, i.e. `E(Y|X)`. 

* In addition, we can also predict an individual's score ($Y_i$) for any value of `X`. From our regression model, we have the following equation that mathematically represents the relationship between conscientiousness and self-rated health: 

$$\hat{health}_{i} = 1.6569733 + 0.4904059 * consc_{i}$$
<br> 

* For example, if we know someone's conscientiousness score is `3.5`, we can easily predict their score for self-rated health according to our model: 

$$\hat{health} = 1.6569733 + 0.4904059*3.5 = 3.374$$


* The `predict()` function gives us an easy way to get the predicted `Y` values from all the `X` values in our dataset.  

```{r}
predict(model)
```


* This should look familiar, as we already have gotten this information from `broom::augment()`. 

```{r}
augment(model)$.fitted
```


### Prediction bands

* We can use this information to create "prediction bands". First we will generate our predicted values (i.e. fitted values) along with a "prediction interval" (lower and upper bound) for each of these values. 

```{r warning=FALSE}
predicted <- predict(model, interval = "prediction")
predicted
```


* Next we'll bind these predicted values (and their prediction intervals) to our original dataset. 

```{r}
new_df <- cbind(health, predicted)
new_df
```


* And finally, we'll plot a prediction band on top of the data by adding a `geom_ribbon()`. This prediction band gives us, for every value od `X`, the interval that represents the range of values that is likely to contain the value of a single new individual observation. Unlike confidence intervals, prediction intervals predict the spread for individual observations rather than the mean.

```{r}
new_df %>% 
  ggplot(aes(x = consc, y = sr_health)) +
  geom_point() +
  geom_smooth(method=lm,se=TRUE) +
  geom_ribbon(aes(ymin = lwr, ymax = upr), fill = "blue", alpha = 0.1) + # prediction band
  labs(x = "Conscientiousness", y = "Self-rated health") +
  theme_minimal()
```

>**Question:** Why is the prediction band wider than the confidence band around our regression line?

>**Answer:** Because there is greater variation in predicting an individual value rather than a collection of individual values (i.e., the mean) the prediction band is wider

### Out-of-sample prediction

* Remember, we can plug *any* `X` value (i.e. conscientiousness score) into our regression equation and predict the corresponding `Y` value (i.e. self-rated health score). And when I say *any* `X` value, I mean that it doesn't have to be an actual observation from our sample. We can also predict out-of-sample! 

* To illustrate this, we'll use a data frame that has new `X` values (conscientiousness scores). Let's pretend that we collected this data from a completely new sample of people.

```{r}
# read in new data
consc_data_new <- import("https://raw.githubusercontent.com/uopsych/psy612/master/labs/lab-3/data/consc_new.csv")

# let's view it
consc_data_new
```


* Now we can predict `Y` values for these out-of-sample `X` values based on the coefficients from our regression model. We just have to tell the `predict()` function what our `newdata` is. 

```{r}
predict(model, newdata = consc_data_new)
```

## Other visualization tools

* `sjPlot::plot_model()`

```{r}
plot_model(model = model,    # name of model object
           type = "pred",    # show predicted values (i.e. regression line)
           show.data = TRUE, # include data points on plot
           jitter = TRUE)    # add small amount of random variation to  to prevent overlap
```

* `ggpubr::ggscatter()`

```{r}
ggscatter(data = health,              # name of data.frame
          x = "consc",                # IV (must be quoted)
          y = "sr_health",            # DV (must be quoted)
          add = "reg.line",           # add regression line
          xlab = "Conscientiousness", # x-axis label
          ylab = "Self-rated health", # y-axis label
          conf.int = TRUE,            # show 95% confidence band around regression line
          cor.coef = TRUE)            # display correlation coefficient and p-value
```

***

# Regression with matrix algebra

* Create the **`X`** matrix 

```{r}
x_mat <- health %>% # start with the original data frame
  mutate(ones = rep(1, nrow(.))) %>% # create a column of 1's to represent the intercept
  select(ones, consc) %>% # select only the column of 1's and X variable
  as.matrix() # coerce to a matrix

print(x_mat)
```


* Create the **`Y`** matrix 

```{r}
y_mat <- health %>% # start with the original data frame
  select(sr_health) %>% # select just the Y variable
  as.matrix() # coerce to a matrix

print(y_mat)
```


* Apply the matrix algebra formula to solve for the **`b`** matrix

$$\mathbf{b} = (\mathbf{X'X})^{-1} \mathbf{X'Y}$$

```{r}
solve(t(x_mat) %*% x_mat) %*% (t(x_mat) %*% y_mat)
```


* The `b`'s we just solved for using matrix algebra match the coefficients we get from `lm()`! 

```{r}
model$coefficients
```

***

# The General Linear Model

```{r}
guyer <- carData::Guyer
```

* Look at the first few rows

```{r}
head(guyer)
```

* Look at the structure of the data 

```{r}
str(guyer)
```


* Covert the `condition` variable to `0's` and `1's`. We will talk more about dummy coding in a future lab. 

```{r}
guyer <-  guyer %>% 
  mutate(condition = case_when(condition == "public" ~ 0,
                               condition == "anonymous" ~ 1))

```


## *t*-test

```{r}
t_test <- t.test(formula = cooperation ~ condition, data = guyer, var.equal = TRUE)
t_test
```

## Correlation 

```{r}
cor_test <- cor.test(formula = ~ cooperation + condition, data = guyer) # note the one-sided formula
cor_test
```

## ANOVA

```{r}
anova_test <- aov(formula = cooperation ~ condition, data = guyer)
summary(anova_test)
```

## Regression

```{r}
regression <- lm(formula = cooperation ~ condition, data = guyer)
summary(regression)
```

***

# Minihacks

## Minihack 1: Calculating confidence intervals{#minihack1}

* For this minihack, we will refer back to the example about conscientiousness and health. We used `confint()` to calculate the 95% CI for our regression coefficients (slope and intercept). Your job is start with the 

```{r eval=FALSE}
model <- lm(sr_health ~ consc, data = health)
```


1. Calculating confidence intervals "by hand". 

```{r}
model <- lm(sr_health ~ consc, data = health)
model_summary <- summary(model)

# extract coefficients
int <- model_summary$coefficients[[1,1]]
slope <- model_summary$coefficients[[2,1]]

# extract standard errors of coefficients
int_se <- model_summary$coefficients[[1,2]]
slope_se <- model_summary$coefficients[[2,2]]

# df for t-distribution (will be denominator df from F statistic)
df <- model_summary$fstatistic[["dendf"]]

# intercept 95% CI 
int_ci_l <- int - qt(.975, df = df)*int_se
int_ci_u <- int + qt(.975, df = df)*int_se

# slope 95% CI 
slope_ci_l <- slope - qt(.975, df = df)*slope_se
slope_ci_u <- slope + qt(.975, df = df)*slope_se
```

2. Verify that your answer corresponds to the result from `confint()`. 

```{r}
confint(model)
```


***

## Minihack 2: Matrix algebra

* Continuing with the `guyer` dataset example, use matrix algebra to manually calculate the intercept and slope for the regression equation (`cooperation` ~ `condition`). 

* Hint: To find the inverse of a matrix, use the `solve()` function. Refer back to the [lab on matrix algebra](https://uopsych.github.io/psy611/labs/lab-3.html){target="_blank"} from 611 for a refresher on other matrix operations if needed. 

1. Create the Matrix $\mathbf{X}$ & Vector $\mathbf{Y}$

```{r}
x <- guyer %>% 
  mutate(ones = rep(1, nrow(.))) %>% 
  select(ones, condition) %>% 
  as.matrix() 

y <- guyer %>% 
  select(cooperation) %>%
  as.matrix()
```

2. Produce $\mathbf{X'}$ (also called $\mathbf{X^T}$ or the transpose of $\mathbf{X}$)

```{r}
x_t <- t(x)
```

3. Produce $\mathbf{X'X}^{-1}$ (inverse of $\mathbf{X'X}$)

```{r}
xtx_inv <- solve(x_t %*% x)
xtx_inv
```

4. Produce $\mathbf{X'Y}$

```{r}
xt_y <- x_t %*% y
xt_y
```

5. Produce $\mathbf{B = (X'X)}^{-1}\mathbf{X'Y}$

```{r}
b <- xtx_inv %*% xt_y
b
```

6. Confirm your results using the `lm()` function in R.

```{r}
regression <- lm(formula = cooperation ~ condition, data = guyer)
regression$coefficients
```

***

## Minihack 3

***
